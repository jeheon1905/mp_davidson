#!/usr/bin/env python3
"""
Plot timer breakdown from JSON file generated by parse_gospel_logs.py
"""

import json
import argparse
import numpy as np
import matplotlib.pyplot as plt


def setup_plot_style(base_font_size=14):
    """
    Set up plot style with consistent font sizes.
    
    Args:
        base_font_size (int): Base font size. Other elements scale proportionally.
    """
    scale_factors = {
        "title": 1.3,
        "label": 1.15,
        "tick": 1.0,
        "legend": 0.85,
    }
    
    plt.rcParams.update({
        "font.size": base_font_size,
        "axes.titlesize": base_font_size * scale_factors["title"],
        "figure.titlesize": base_font_size * scale_factors["title"],
        "axes.labelsize": base_font_size * scale_factors["label"],
        "xtick.labelsize": base_font_size * scale_factors["tick"],
        "ytick.labelsize": base_font_size * scale_factors["tick"],
        "legend.fontsize": base_font_size * scale_factors["legend"],
        "legend.title_fontsize": base_font_size * scale_factors["legend"],
        "font.family": "sans-serif",
        "font.sans-serif": ["DejaVu Sans", "Arial", "Helvetica"],
        "figure.dpi": 100,
        "savefig.dpi": 300,
        "figure.autolayout": True,
    })


def get_category_colors():
    """
    Define default colors for timer categories.
    """
    colors = {
        "Diagonalization": "tab:blue",
        "Initialization": "tab:red",
        "Calc. potential and energy": "tab:pink",
        "ETC": "gray",
    }
    return colors


def plot_timer_breakdown(
    json_data,
    labels=None,
    output_file="timer_breakdown.svg",
    figsize=(9, 6),
    bar_width=0.8,
    save_legend_separately=True,
    legend_cols=3,
    font_size=14,
    ylabel="SCF time (sec)",
    colors=None
):
    """
    Draw stacked bar plot for timer breakdown from JSON data.
    
    Args:
        json_data: List of dictionaries loaded from JSON file
        labels: X-axis labels (if None, use method names from JSON)
        output_file: Output filename
        figsize: Figure size tuple (width, height)
        bar_width: Width of bars (0-1)
        save_legend_separately: If True, save legend as separate file
        legend_cols: Number of columns in legend
        font_size: Base font size
        ylabel: Y-axis label
        colors: Color mapping for categories (if None, use defaults)
    """
    setup_plot_style(base_font_size=font_size)
    
    if colors is None:
        colors = get_category_colors()
    
    # Extract method names if labels not provided
    if labels is None:
        labels = [item['method'] for item in json_data]
    
    # Extract categories (exclude 'method', 'total_time', 'acc_fold')
    excluded_keys = {'method', 'total_time', 'acc_fold', 'scf_steps'}
    categories = [key for key in json_data[0].keys() if key not in excluded_keys]
    
    x = np.arange(len(labels))
    bottom = np.zeros(len(labels))
    
    fig, ax = plt.subplots(figsize=figsize)
    
    # Draw stacked bars
    bars = []
    for category in categories:
        values = [data.get(category, 0) for data in json_data]
        bar = ax.bar(
            x,
            values,
            width=bar_width,
            bottom=bottom,
            label=category,
            color=colors.get(category, "gray"),
        )
        bars.append(bar)
        bottom += values
    
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.set_ylabel(ylabel)
    ax.grid(True, axis='y', alpha=0.3, linestyle='--')
    
    if save_legend_separately:
        ax.legend().set_visible(False)
        
        # Create separate legend figure
        fig_legend = plt.figure(figsize=(6, 2))
        handles, labels_legend = ax.get_legend_handles_labels()
        fig_legend.legend(
            handles,
            labels_legend,
            loc="center",
            ncol=legend_cols,
            frameon=True,
            fancybox=True,
            shadow=False,
        )
        
        legend_filename = output_file.rsplit(".", 1)[0] + "_legend." + output_file.rsplit(".", 1)[1]
        fig_legend.savefig(legend_filename, bbox_inches="tight")
        print(f"[+] Saved legend to {legend_filename}")
        plt.close(fig_legend)
    else:
        ax.legend(loc="upper right", ncol=2)
    
    plt.tight_layout()
    fig.savefig(output_file, bbox_inches="tight")
    print(f"[+] Saved timer breakdown plot to {output_file}")
    plt.close(fig)


def main():
    parser = argparse.ArgumentParser(
        description='Plot timer breakdown from JSON file generated by parse_gospel_logs.py'
    )
    parser.add_argument(
        'json_file',
        help='Input JSON file with aggregated timer data'
    )
    parser.add_argument(
        '-o', '--output',
        default='timer_breakdown.svg',
        help='Output file for plot (default: timer_breakdown.svg)'
    )
    parser.add_argument(
        '--labels',
        nargs='+',
        help='Custom labels for x-axis (if not provided, use method names from JSON)'
    )
    parser.add_argument(
        '--methods',
        nargs='+',
        help='Filter which methods to plot (if not provided, plot all methods from JSON)'
    )
    parser.add_argument(
        '--figsize',
        nargs=2,
        type=float,
        default=[5.0, 4.0],
        help='Figure size (width height) (default: 5.0 4.0)'
    )
    parser.add_argument(
        '--font-size',
        type=int,
        default=18,
        help='Base font size (default: 18)'
    )
    parser.add_argument(
        '--bar-width',
        type=float,
        default=0.8,
        help='Bar width (0-1) (default: 0.8)'
    )
    parser.add_argument(
        '--separate-legend',
        action='store_true',
        help='Save legend as separate file'
    )
    parser.add_argument(
        '--legend-cols',
        type=int,
        default=3,
        help='Number of columns in legend (default: 3)'
    )
    parser.add_argument(
        '--ylabel',
        default='SCF time (sec)',
        help='Y-axis label (default: "SCF time (sec)")'
    )
    
    args = parser.parse_args()
    
    # Load JSON data
    print(f"[+] Loading JSON file: {args.json_file}")
    with open(args.json_file, 'r') as f:
        json_data = json.load(f)
    
    print(f"[+] Found {len(json_data)} methods in JSON file")
    
    # Filter methods if specified
    if args.methods:
        # Create a mapping from method name to data
        data_map = {item.get('method'): item for item in json_data}
        
        # Rebuild json_data in the order specified by args.methods
        filtered_data = []
        for method in args.methods:
            if method in data_map:
                filtered_data.append(data_map[method])
            else:
                print(f"[!] Warning: Method '{method}' not found in JSON file")
        
        if not filtered_data:
            print(f"[!] Error: No methods matched the filter {args.methods}")
            print(f"    Available methods: {list(data_map.keys())}")
            return
        
        json_data = filtered_data
        print(f"[+] Filtered to {len(json_data)} methods: {[item.get('method') for item in json_data]}")
    
    # Print summary
    print("\nSummary:")
    for item in json_data:
        method = item.get('method', 'Unknown')
        total_time = item.get('total_time', 0)
        acc_fold = item.get('acc_fold', 0)
        print(f"  {method}: {total_time:.2f} sec (speedup: {acc_fold:.2f}x)")
    
    # Plot
    plot_timer_breakdown(
        json_data,
        labels=args.labels,
        output_file=args.output,
        figsize=tuple(args.figsize),
        bar_width=args.bar_width,
        save_legend_separately=args.separate_legend,
        legend_cols=args.legend_cols,
        font_size=args.font_size,
        ylabel=args.ylabel
    )


if __name__ == '__main__':
    main()
